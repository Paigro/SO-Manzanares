[       Utils       ]

*   Las opciones cortas pueden combinarse detrás de un solo - siempre que no haya ambigüedad. 
    Las opciones que requieren argumento deben ir seguidas de su valor

*   ~   representa el directorio home del usuario

STDIN_FILENO  = 0   # entrada estandar
STDOUT_FILENO = 1   # salida estandar


╔══════════════════════════════════════════╗
║                   USERS                  ║
╚══════════════════════════════════════════╝
El prompt es la cadena que muestra la shell esperando comandos
Cada usuario puede tener un prompt distinto
    $ sudo -i   # inicia una shell como root (cambia usuario y entorno)
    $ exit      # termina la shell actual y devuelve un código de retorno


╔══════════════════════════════════════════╗
║            BUSQUEDAS EN MANUAL           ║
╚══════════════════════════════════════════╝
Secciones importantes:
$ man man
    - NAME: nombre y descripción breve
    - SYNOPSIS: forma de uso
    - DESCRIPTION: descripción detallada
    - OPTIONS: opciones disponibles
    - SEE ALSO: comandos relacionados

$ man 1 time   # Comando de usuario
$ man 2 time   # Llamada al sistema

# Busqueda por tema
$ man -k <palabra clave>    # Busca una palabra clave                       [man -k time ]
$ apropos <palabra clave>   # Igual que man -k                              [apropos time]
$ whatis <palabra clave>    # Devielve una descripcion corta del comando    [whatis time ]
$ sudo mandb                # Actualiza la base de datos, necesita ser root o sudo


╔══════════════════════════════════════════╗
║            VARIABLES Y ENTORNO           ║
╚══════════════════════════════════════════╝

=============== VARIABLES =================
$ env   # Consulta el entorno de la shell (Variables de entorno)
            |       |
            v       v
    $USER  # usuario
    $UID   # id del usuario
    $HOME  # directorio personal
    $PWD   # directorio actual
    $SHELL # shell por defecto
    $?     # Contiene el código de salida del último comando
    $$     # PID del proceso actual (shell)
    $PPID  # PID del padre
    $PATH  # rutas de búsqueda

Definir una variable nombre=valor ¡¡CUIDADO CON LOS ESPACIOS, NO DEBE HABER!!

con $ antes de una variable obtenemos su valor
Podemos aislar el valor de una variable 
    - variable=1+1
    - ${variable}2 => resulte en "1+1=2"
PS1 cambia el prompt del bash ( mirar man bash)

$ echo $PATH
$ export PATH=$PATH:$PWD

Diferencia entre "./" y "$PWD":
    ./      ruta relativa, insegura
    $PWD    ruta absoluta, recomendada

======= INFORMACION SOBRE COMANDOS Y VARIABLES ===========
$ which bash                # Indica el ejecutable que se lanza buscando en el PATH, pero no detecta comandos internos.
$ type bash cd echo test    # Indica como interpreta la shell un comando
                    # built-in
                    # ejecutable externo
                    # alias
                    # función

$ type es más completo y más correcto para saber qué se ejecuta realmente. Tipos:
    - Alias	    # Atajo definido por el usuario
    - Función   # Código bash reutilizable
    - Built-in  # Comando interno de la shell
    - Externo   # Fichero ejecutable
    - Keyword   # Palabra de la sintaxis bash


╔══════════════════════════════════════════╗
║       MANEJO DE CADENAS Y FICHEROS       ║
╚══════════════════════════════════════════╝

============== CONTENIDO ================
$ echo -e # habilita la interpretacion de la cadena de texto
$ echo -e "zorro\npájaro\nvaca\ncaballo\nabeja" > texto1 # Vuelca la salida al archivo texto1
$ sort texto1                                            # Ordena el contenido de texto1

$ cat  "archivo"    # muestra el contenido del archivo
    - cat  "archivo1" "archivo2" "archivo3" > "archivodestino"   # muestra el contenido del archivo

=========== INFORMACION DEL FICHERO =============
$ wc texto1 texto2 texto3   # Consulta cantidad de lineas - palabras - caracteres - nombre
    - wc -l texto1    # solo líneas
    - wc -w texto1    # solo palabras
    - wc -c texto1    # solo bytes (1 byte = 1 character)
    - wc -m texto1    # caracteres (importante con UTF-8)
    - wc -L texto1    # longitud de la línea más larga


[-------------- ls --------------]
$ ls -l *.txt         # muestra informacion de los ficheros acabados en .txt
    -l  # Listado largo: permisos, enlaces, propietario, grupo, tamaño, fecha y nombre
    -a  # Muestra todos los ficheros, incluidos los ocultos (empiezan por .)
    -h  # Muestra tamaños legibles (K, M, G). Se usa junto con  -l.
    -R  # Listado recursivo de directorios
    -d  # Muestra el directorio como entrada, no su contenido
    -i  # Muestra el número de inodo de cada fichero
    -F  # Añade un carácter al final según el tipo:
            / directorio
            * ejecutable
            @ enlace simbólico
    -p  #Añade / al final de los directorios
OPCIONES DE ORDENACIÓN    
    -t  # Ordena por fecha de modificación (más reciente primero)
    -S  # Ordena por tamaño (mayor primero)
    -X  # Ordena por extensión
    -r  # Invierte el orden del listado
OPCIONES DE FORMATO    
    -1              # Muestra un fichero por línea
    --color=auto    # Muestra colores según el tipo de fichero 
    -C              # Muestra el listado en columnas (por defecto)

$ dmesg	    # Muestra mensajes del kernel (necesita permisos de root/sudo)
$ wc -l	    # Cuenta líneas
$ head -<n> # Muestra primeras n líneas
$ tail -<n> # Muestra últimas n líneas
$ tail -f   # Sigue el fichero en tiempo real (se corta si se modifica o trunca el archivo)
$ tail -F   # Sigue el fichero aunque se recree (reintenta conectar con el archivo continuamente)

$ tr        # Traslada o modifica caracteres


╔══════════════════════════════════════════╗
║          SISTEMA DE FICHEROS             ║
╚══════════════════════════════════════════╝

=========== DIRECTORIO DE TRABAJO =============
$ cd    # Mueve el directorio del usuario
    -       # Mueve al directorio anterior
$ pwd   # Devuelve el path al directorioactual (Equivalente a la variable PWD)

======= MANEJO DE FICHEROS/DIRECTORIOS =======
$ mkdir # Crea un directorio
    -p	    # Crea directorios intermedios si no existen
    -v	    # Muestra un mensaje por cada directorio creado (verbose)
    -m	    # Establece permisos al crear el directorio (en octal)
$ rmdir # Elimina un directorio vacio
    -p      # Elimina el directorio y sus directorios padre si quedan vacíos
    -v      # Muestra un mensaje por cada directorio eliminado.
$ rm    # Elimina ficheros y directorios, borra ficheros, no pide confirmación por defecto
    -r      # Borra directorios y su contenido de forma recursiva
    -i      # Pregunta antes de borrar cada fichero
    -f      # Fuerza el borrado sin preguntar (ignora errores)
    -v      # Muestra qué se borra (modo detallado)
    -d      # Borra directorios vacíos (similar a rmdir)

--one-file-system
No cruza a otros sistemas de ficheros al borrar
$ cp <fichero_origen> <fichero_destino>                      # Copia un fichero
$ cp <fichero_origen> <fichero_origen2> <destino_directorio> # Copia varios ficheros
    -r      # Copia directorios de forma recursiva
    -i      # Pregunta antes de sobrescribir un fichero existente
    -f      # Fuerza la copia, sobrescribiendo sin preguntar
    -v      # Muestra qué ficheros se copian (verbose)
    -p      # Preserva atributos: permisos, propietario y fechas
    -a      # Modo archivo (archive): equivalente a -r -p y conserva enlaces
    -u      # Copia solo si el fichero origen es más nuevo
    -t <DIR># specifica el directorio destino explícitamente
mv <origen> <origen2> <destino_directorio>  # Mueve o renombra ficheros y directorios
                                            # Si destino no existe -> renombra
                                            # Si destino es un directorio -> mueve dentro
    -i      # Pregunta antes de sobrescribir un fichero existente
    -f      # Fuerza el movimiento, sobrescribiendo sin preguntar
    -v      # Muestra qué se mueve (verbose)
    -n      # No sobrescribe ficheros existentes
    -t <DIR># Especifica explícitamente el directorio destino


╔══════════════════════════════════════════╗
║          BUSQUEDA DE FICHEROS            ║
╚══════════════════════════════════════════╝

[-------------- find --------------]
$ find <ruta_de_búsqueda> # Busqueda de ficheros (recursivo)
BUSQUEDA POR NOMBRE
    -name "archivo.txt"     # Busca por nombre exacto
    -iname "archivo.txt"    # Busca ignorando mayúsculas/minúsculas
    -name "*.pdf"           # Busca archivos con extensión .pdf usando comodines
BUSQUEDA POR TIPO
    -type f     # Busca solo archivos
    -type d     # Busca solo directorios
    -type l     # Busca enlaces simbólicos
BUSQUEDA POR TAMAÑO
    -size +100M     # Archivos mayores a 100 Megabytes (c, b, k, M y G | + ó -)
BUSQUEDA POR TIEMPO
    -mtime -7   # Modificados en los últimos 7 días.
    -mmin -60   # Modificados en los últimos 60 minutos.
    -atime -1   # Accedidos en el último día.
BUSQUEDA POR USUARIO Y PERMISO
    -user usuario   # Archivos que pertenecen a un usuario específico.
    -perm 777       # Archivos con permisos 777.
ACCIONES SOBRE RESULTADOS
    -delete                 # Borra los archivos encontrados
    -exec [comando] {} \;   # Ejecuta un comando sobre cada resultado
    -ls                     # Muestra información detallada (tipo ls -dils)
OPERADORES LOGICOS
    -o          # Operador OR 
    -not ó -!    # Operador NOT
    -a          # Operador AND (es el comportamiento por defecto)


╔═════════════════════════════════════════════════════╗
║  REDIRECCIONES TUBERIAS Y EXPRESIONES REGULARES     ║
╚═════════════════════════════════════════════════════╝

Todo lo descrito a continuación se usa para complementar comandos y redirigir salidas

DESCRIPTORES DE ARCHIVO
    0 # Entrada estándar (stdin) - Teclado
    1 # Salida estándar (stdout) - Pantalla
    2 # Salida de error (stderr) - Pantalla (mensajes de error)
OPERADORES DE REDIRECCIÓN
    >                     # Redirige la salida estándar a un fichero (sobrescribe/trunca)
    >>                    # Redirige la salida estándar a un fichero (añade al final/append)
    2>                    # Redirige solo los errores (descriptor 2) a un fichero
    2>>                   # Añade los errores (descriptor 2) al final de un fichero
    &> ó > archivo 2>&1   # Redirige la salida estándar (descriptor 1) a archivo, redirige los errores (descriptor 2) a donde apunta la salida estandar
    <                     # Redirige la entrada estándar desde un fichero hacia un comando
    | (Tubería/Pipe)      # Pasa la salida de un comando como entrada al siguiente
DISPOSITIVOS ESPECIALES
    /dev/null   # El "agujero negro" del sistema. Se usa para descartar salidas no deseadas
COMANDOS DE INSPECCION Y FILTRO
    cat         # Muestra el contenido de un archivo
    sort        # Ordena las líneas de un texto o archivo
    grep        # Busca patrones (texto o expresiones regulares) dentro de archivos
    echo $?     # Muestra el código de salida del último comando ejecutado (0 = éxito)
EXPRESIONES REGULARES
    .       # Representa cualquier carácter único
    *       # El carácter anterior se repite 0 o más veces
    $       # Indica el final de una línea [ja$ busca palabras que terminan en ja]
    ^       # Indica el inicio de una línea
    [ ]     # Define un rango o conjunto de caracteres [a-z]
    {n,m}   # El carácter anterior se repite entre n y m veces (requiere grep -E)

[-------------- GREP --------------]
$ grep <patron> <fichero1> <fichero2>   # Busca líneas que coincidan con un patrón (expresión regular)
                                        # Imprime las líneas que contienen el patrón
                                        # El patrón puede ser texto literal o una expresión regular
    -i              # Ignora mayúsculas y minúsculas
    -v              # Muestra las líneas que NO coinciden con el patrón
    -n              # Muestra el número de línea
    -c              # Cuenta el número de líneas que coinciden
    -l              # Muestra solo los nombres de ficheros que coinciden
    -w              # Busca palabras completas
    -r              # Búsqueda recursiva en directorios
    -E              # Usa expresiones regulares extendidas (egrep)
    -F              # Búsqueda de texto literal (sin expresiones regulares)
    --color=auto    # Resalta las coincidencias

╔═════════════════════════════════════════════════════╗
║               PROGRAMACIÓN EN SHELL                 ║
╚═════════════════════════════════════════════════════╝

SCRIPT SHELL
Fichero de texto que contiene comandos de bash y se ejecuta como un programa.

Primera línea del script. Indica qué intérprete debe ejecutar el script.
#!/bin/bash
--
    chmod +x script.sh      # Otorga permiso de ejecución a un script

Ejecuta el script desde el directorio actual
./script.sh

variable=$(comando)
Guarda la salida estándar del comando en una variable
--
    cut -d':' -f1 fichero   # Divide líneas usando un delimitador y selecciona campos, útil para procesar texto
    seq 1 5                 # Genera una secuencia de números (1 2 3 4 5)
[-------------- cut --------------]
$ cut <opciones> <archivo>   # Extrae secciones de cada línea de ficheros

SELECCIÓN POR CAMPOS (Básico para archivos delimitados)
    -d ":"      # Define el delimitador de campos (por defecto es el tabulador)
    -f 1        # Selecciona solo el primer campo
    -f 1,3      # Selecciona los campos 1 y 3
    -f 1-3      # Selecciona el rango de campos del 1 al 3
    -f 2-       # Selecciona desde el campo 2 hasta el final de la línea

SELECCIÓN POR CARACTERES
    -c 1        # Selecciona solo el primer carácter
    -c 1,5,10   # Selecciona los caracteres en las posiciones 1, 5 y 10
    -c 1-10     # Selecciona el rango de caracteres del 1 al 10
    -c 5-       # Selecciona desde la posición 5 hasta el final de la línea

SELECCIÓN POR BYTES
    -b 1-10     # Selecciona el rango de bytes del 1 al 10

OTRAS OPCIONES
    -s          # No imprime líneas que no contengan el delimitador
    --complement    # Invierte la selección (extrae todo excepto lo indicado)
    --output-delimiter=","  # Cambia el delimitador en la salida generada

========= ARGUMENTOS =========
$0      # Nombre del script
$1      # Primer argumento pasado al script
$2      # Segundo argumento pasado al script
$#      # Número total de argumentos
$@      # Lista de todos los argumentos

======= CÓDIGO DE SALIDA =======
    exit N  # Finaliza el script devolviendo el código N.
            # 0  → ejecución correcta
            # ≠0 → error

======= CONDICIONALES =======
    if [ condición ]; then
        comandos
    else
        comandos
    fi
CONDICIONES COMUNES
    -f fichero              # Verdadero si existe y es un fichero regular
    -d directorio           # Verdadero si es un directorio
    -e ruta                 # Verdadero si existe
    -ne / -eq / -lt / -gt   # Comparaciones numéricas

======= BUCLES =======
Foreach itera sobre una lista de valores o ficheros.
for var in lista; do
    comandos
done
For en rango
for ((i=0; i<5; i++)); do
    echo $i
done

======= FUNCIONES =======
function nombre(){
    comandos
}
nombre(){
    comandos
}
LLAMADA
nombre_funcion argumento1 argumento2...

$ sed       # Edita texto, usado para borrar registros

# Esto es una especie de switch interactivo:
select  # Crea un menú interactivo
case    # Ejecuta acciones según la opción elegida
break   # Sale del menú (select)

[----- read -----]
$ read <VAR1> <VAR2> <VAR3>     # Comando de bash que lee una línea desde la entrada estándar y guarda el valor en una o varias variables
                                # read devuelve 0  -> lectura correcta
                                # read devuelve ≠0 -> fin de fichero o error
    -p "Mensaje: " <VAR>    # Muestra un mensaje antes de leer la entrada
    -s <VAR>                # No muestra lo que el usuario escribe (contraseñas)
    -t <SEG> <VAR>          # Espera un número limitado de segundos
    -n 1 <VAR>              # Lee un único carácter
    -r <VARIABLE>           # Evita que \ sea interpretado como carácter especial

LECTURA DESDE UN FICHERO
while read -r LINEA; do
    echo "$LINEA"
done < fichero.txt

=== ENTRADA ESTÁNDAR ===
La entrada que recibe read normalmente viene del teclado,
pero puede redirigirse desde un fichero o una tubería.


╔═════════════════════════════════════════════════════╗
║             API DEL SISTEMA OPERATIVO               ║
╚═════════════════════════════════════════════════════╝

$ gcc error.c     # Compila un script en c
    -g          # Incluye símbolos para depurar
    -o <NOMB>   # Nombre del ejecutable
$ gdb ./error           # Debugea el script
    list            # Muestra el código
    break <línea>   # Pone un punto de parada
    run             # Ejecuta el programa
    step            # Entra en funciones
    next            # Avanza línea a línea
    print <var>       # Muestra el valor de una variable
    Gestión de errores

$ open  # Devuelve descriptor ≥ 0 -> éxito
        # Devuelve descriptor -1 -> error

GESTIÓN DE ERRORES
if (fd == -1) {
    perror("open");
    return 1;
}
errno       # Variable global con el código de error definida en <errno.h>
strerror(3) # Convierte errno en un mensaje legible

LIBRERIAS Y LLAMADAS AL SISTEMA
id          # Comando que muestra información del usuario
getpwuid    # Función de librería que devuelve información de un usuario (Nombre, grupo y directorio home)
getuid      # Llamada al sistema que obtiene el ID del usuario actual
mi_id       # Con argumento -> muestra datos del usuario
            # Sin argumento -> usa el UID del proceso

INFORMACION DEL SISTEMA
uname(1)    # Comando que muestra información del sistema
uname(2)    # Llamada al sistema que obtiene:
        # Nombre del SO
        # Versión del kernel
        # Nombre del host
        # Arquitectura


╔═════════════════════════════════════════════════════╗
║          MANEJO DE FICHEROS Y DIRECTORIOS           ║
╚═════════════════════════════════════════════════════╝

$ stat <fichero/directorio>  # Comando que muestra información detallada de un fichero o directorio, obtenida directamente del sistema de ficheros.
    -c  # Formato personalizado de salida
        %a   # Permisos en octal
        %A   # Permisos en texto
        %s   # Tamaño en bytes
        %y   # Fecha de última modificación
        %n   # Nombre del fichero
        %i   # Número de inodo
        %h   # Número de enlaces
    -f  # Muestra información del sistema de ficheros
    -L  # Sigue enlaces simbólicos
    -t  # Muestra la información en formato breve

File                    # Nombre del fichero
Size                    # Tamaño del fichero en bytes
Blocks                  # Número de bloques ocupados en disco
IO Block                # Tamaño del bloque de E/S
File type               # Tipo de fichero (regular, directorio, enlace simbólico, etc.)
Device                  # Dispositivo donde está almacenado
Inode                   # Número de inodo del fichero
Links                   # Número de enlaces duros
Access                  # Permisos del fichero en formato simbólico y octal
Uid / Gid               # ID del usuario y grupo propietario
Access time (atime)     # Último acceso al fichero
Modify time (mtime)     # Última modificación del contenido
Change time (ctime)     # Último cambio en metadatos (permisos, propietario)
Birth time (si existe)  # Fecha de creación del fichero

[---------- Cadenas y Errores (3) ----------]
CADENAS
    atoi()      # Convierte una cadena (ASCII) a entero (int)
    sprintf()   # Escribe texto formateado en un buffer (como printf pero a una variable)
    strlen()    # Devuelve la longitud de una cadena (sin contar el \0)
    strcpy()    # Copia una cadena a otra (Cuidado con el tamaño del destino!)
    strcat()    # Concatena (une) una cadena al final de otra
    strcmp()    # Compara dos cadenas (devuelve 0 si son idénticas)

printf()
    %d o %i	# int	         -> Entero estándar (normalmente 32 bits)
    %ld	    # long int	     -> Entero largo (normalmente 32 o 64 bits según el sistema)
    %lld	# long long int	 -> Entero extra largo (mínimo 64 bits)
    %u	    # unsigned int	 -> Entero sin signo (solo positivos)
    %lu	    # unsigned long	 -> Entero largo sin signo

=== Macros para saber tipo de archivo ===
m = struct stat.st_mode
S_ISREG(m)  # Fichero regular (un archivo normal de texto, ejecutable, etc.)
S_ISDIR(m)  # Directorio
S_ISLNK(m)  # Enlace simbólico (soft link)
S_ISCHR(m)  # Dispositivo de caracteres (ej: terminales /dev/tty)
S_ISBLK(m)  # Dispositivo de bloques (ej: discos duros /dev/sda)
S_ISFIFO(m) # FIFO o tubería con nombre (named pipe)
S_ISSOCK(m) # Socket de red o local

char *ctime(const time_t *timep);   // Convierte un valor de tiempo de calendario (segundos) en una cadena de caracteres terminada en nulo (\0)
                                    // Devuelve siempre una cadena de 26 caracteres con el formato: Wed Dec 15 13:30:00 2025\n\0

[-------------- chmod (1) --------------]
$ chmod [opciones] <modo> <archivo> # Cambiar los permisos de acceso (modo) de archivos o directorios. Controla quién puede leer, escribir o ejecutar un archivo
MODO OCTAL 
    4: Lectura (r)
    2: Escritura (w)
    1: Ejecución (x)
    0: Sin permisos
(Dueño | Grupo | Otros)
MODO SIMBÓLICO
    Usuarios: u (user/owner), g (group), o (others), a (all)
    Operadores: + (añadir), - (quitar), = (asignar exactamente)
    Permisos: r (read), w (write), x (execute)

[-------------- ln (1) --------------]
$ ln [opciones] <archivo_origen> <nombre_enlace>   # Crea enlaces (vínculos) entre archivos. Permite que un mismo archivo tenga múltiples nombres o rutas de acceso
    -s (--symbolic): Crea un enlace simbólico en lugar de uno duro
    -f (--force): Elimina el archivo de destino si ya existe para crear el nuevo enlace
    -v (--verbose): Muestra el nombre de cada archivo antes de enlazarlo
    -n (--no-dereference): Trata el destino como un archivo normal si es un enlace simbólico a un directorio (evita crear enlaces dentro del destino)
TIPOS DE ENLACES
Enlace Duro (Hard Link): Es el comportamiento por defecto. Crea una nueva entrada en el directorio que apunta al mismo número de inodo que el original
Enlace Simbólico (Soft/Symbolic Link): Crea un archivo especial que contiene la ruta (un puntero) al archivo original. Es similar a un acceso directo