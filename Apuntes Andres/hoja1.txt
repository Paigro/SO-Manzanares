[       Utils de comandos       ]

*   Las opciones cortas pueden combinarse detrás de un solo - siempre que no haya ambigüedad. 
    Las opciones que requieren argumento deben ir seguidas de su valor.

╔══════════════════════════════════════════╗
║                   USERS                  ║
╚══════════════════════════════════════════╝
El prompt es la cadena que muestra la shell esperando comandos.
Cada usuario puede tener un prompt distinto.
    $ sudo -i   # inicia una shell como root (cambia usuario y entorno).
    $ exit      # termina la shell actual y devuelve un código de retorno.


╔══════════════════════════════════════════╗
║            BUSQUEDAS EN MANUAL           ║
╚══════════════════════════════════════════╝
Secciones importantes:
$ man man
    - NAME: nombre y descripción breve
    - SYNOPSIS: forma de uso
    - DESCRIPTION: descripción detallada
    - OPTIONS: opciones disponibles
    - SEE ALSO: comandos relacionados

$ man 1 time   # Comando de usuario
$ man 2 time   # Llamada al sistema

# Busqueda por tema
$ man -k <palabra clave>    # Busca una palabra clave                       [man -k time ]
$ apropos <palabra clave>   # Igual que man -k                              [apropos time]
$ whatis <palabra clave>    # Devielve una descripcion corta del comando    [whatis time ]
$ sudo mandb                # Actualiza la base de datos, necesita ser root o sudo


╔══════════════════════════════════════════╗
║            VARIABLES Y ENTORNO           ║
╚══════════════════════════════════════════╝

=============== VARIABLES =================
$ env   # Consulta el entorno de la shell (Variables de entorno)
            |       |
            v       v
    $USER  # usuario
    $UID   # id del usuario
    $HOME  # directorio personal
    $PWD   # directorio actual
    $SHELL # shell por defecto
    $?     # Contiene el código de salida del último comando
    $$     # PID del proceso actual (shell).
    $PPID  # PID del padre
    $PATH  # rutas de búsqueda

Definir una variable nombre=valor ¡¡CUIDADO CON LOS ESPACIOS, NO DEBE HABER!!

con $ antes de una variable obtenemos su valor
Podemos aislar el valor de una variable 
    - variable=1+1
    - ${variable}2 => resulte en "1+1=2"
PS1 cambia el prompt del bash ( mirar man bash)

$ echo $PATH
$ export PATH=$PATH:$PWD

Diferencia entre "./" y "$PWD":
    ./      ruta relativa, insegura
    $PWD    ruta absoluta, recomendada

======= INFORMACION SOBRE COMANDOS Y VARIABLES ===========
$ which bash                # Indica el ejecutable que se lanza buscando en el PATH, pero no detecta comandos internos.
$ type bash cd echo test    # Indica como interpreta la shell un comando
                    # built-in
                    # ejecutable externo
                    # alias
                    # función

$ type es más completo y más correcto para saber qué se ejecuta realmente. Tipos:
    - Alias	    # Atajo definido por el usuario
    - Función   # Código bash reutilizable
    - Built-in  # Comando interno de la shell
    - Externo   # Fichero ejecutable
    - Keyword   # Palabra de la sintaxis bash


╔══════════════════════════════════════════╗
║       MANEJO DE CADENAS Y FICHEROS       ║
╚══════════════════════════════════════════╝

============== CONTENIDO ================
$ echo -e # habilita la interpretacion de la cadena de texto
$ echo -e "zorro\npájaro\nvaca\ncaballo\nabeja" > texto1 # Vuelca la salida al archivo texto1
$ sort texto1                                            # Ordena el contenido de texto1

$ cat  "archivo"    # muestra el contenido del archivo
    - cat  "archivo1" "archivo2" "archivo3" > "archivodestino"   # muestra el contenido del archivo

=========== INFORMACION DEL FICHERO =============
$ wc texto1 texto2 texto3   # Consulta cantidad de lineas - palabras - caracteres - nombre
    - wc -l texto1    # solo líneas
    - wc -w texto1    # solo palabras
    - wc -c texto1    # solo bytes (1 byte = 1 character)
    - wc -m texto1    # caracteres (importante con UTF-8)
    - wc -L texto1    # longitud de la línea más larga


[-------------- ls --------------]
$ ls -l *.txt         # muestra informacion de los ficheros acabados en .txt
    -l  # Listado largo: permisos, enlaces, propietario, grupo, tamaño, fecha y nombre
    -a  # Muestra todos los ficheros, incluidos los ocultos (empiezan por .)
    -h  # Muestra tamaños legibles (K, M, G). Se usa junto con  -l.
    -R  # Listado recursivo de directorios
    -d  # Muestra el directorio como entrada, no su contenido
    -i  # Muestra el número de inodo de cada fichero
    -F  # Añade un carácter al final según el tipo:
            / directorio
            * ejecutable
            @ enlace simbólico
    -p  #Añade / al final de los directorios
OPCIONES DE ORDENACIÓN    
    -t  # Ordena por fecha de modificación (más reciente primero)
    -S  # Ordena por tamaño (mayor primero)
    -X  # Ordena por extensión
    -r  # Invierte el orden del listado
OPCIONES DE FORMATO    
    -1              # Muestra un fichero por línea
    --color=auto    # Muestra colores según el tipo de fichero 
    -C              # Muestra el listado en columnas (por defecto)

$ dmesg	    # Muestra mensajes del kernel (necesita permisos de root/sudo)
$ wc -l	    # Cuenta líneas
$ head -<n> # Muestra primeras n líneas
$ tail -<n> # Muestra últimas n líneas
$ tail -f   # Sigue el fichero en tiempo real (se corta si se modifica o trunca el archivo)
$ tail -F   # Sigue el fichero aunque se recree (reintenta conectar con el archivo continuamente)

$ tr        # Traslada o modifica caracteres


╔══════════════════════════════════════════╗
║          SISTEMA DE FICHEROS             ║
╚══════════════════════════════════════════╝

=========== DIRECTORIO DE TRABAJO =============
$ cd    # Mueve el directorio del usuario
    -       # Mueve al directorio anterior
$ pwd   # Devuelve el path al directorioactual (Equivalente a la variable PWD)

======= MANEJO DE FICHEROS/DIRECTORIOS =======
$ mkdir # Crea un directorio
    -p	    # Crea directorios intermedios si no existen
    -v	    # Muestra un mensaje por cada directorio creado (verbose)
    -m	    # Establece permisos al crear el directorio (en octal)
$ rmdir # Elimina un directorio vacio
    -p      # Elimina el directorio y sus directorios padre si quedan vacíos
    -v      # Muestra un mensaje por cada directorio eliminado.
$ rm    # Elimina ficheros y directorios, borra ficheros, no pide confirmación por defecto
    -r      # Borra directorios y su contenido de forma recursiva
    -i      # Pregunta antes de borrar cada fichero
    -f      # Fuerza el borrado sin preguntar (ignora errores)
    -v      # Muestra qué se borra (modo detallado)
    -d      # Borra directorios vacíos (similar a rmdir)

--one-file-system
No cruza a otros sistemas de ficheros al borrar
$ cp <fichero_origen> <fichero_destino>                      # Copia un fichero
$ cp <fichero_origen> <fichero_origen2> <destino_directorio> # Copia varios ficheros
    -r      # Copia directorios de forma recursiva
    -i      # Pregunta antes de sobrescribir un fichero existente
    -f      # Fuerza la copia, sobrescribiendo sin preguntar
    -v      # Muestra qué ficheros se copian (verbose)
    -p      # Preserva atributos: permisos, propietario y fechas
    -a      # Modo archivo (archive): equivalente a -r -p y conserva enlaces
    -u      # Copia solo si el fichero origen es más nuevo
    -t <DIR># specifica el directorio destino explícitamente
mv <origen> <origen2> <destino_directorio>  # Mueve o renombra ficheros y directorios
                                            # Si destino no existe -> renombra
                                            # Si destino es un directorio -> mueve dentro
    -i      # Pregunta antes de sobrescribir un fichero existente
    -f      # Fuerza el movimiento, sobrescribiendo sin preguntar
    -v      # Muestra qué se mueve (verbose)
    -n      # No sobrescribe ficheros existentes
    -t <DIR># Especifica explícitamente el directorio destino


╔══════════════════════════════════════════╗
║          BUSQUEDA DE FICHEROS            ║
╚══════════════════════════════════════════╝

[-------------- find --------------]
$ find <ruta_de_búsqueda> # Busqueda de ficheros (recursivo)
BUSQUEDA POR NOMBRE
    -name "archivo.txt"     # Busca por nombre exacto
    -iname "archivo.txt"    # Busca ignorando mayúsculas/minúsculas
    -name "*.pdf"           # Busca archivos con extensión .pdf usando comodines
BUSQUEDA POR TIPO
    -type f     # Busca solo archivos
    -type d     # Busca solo directorios
    -type l     # Busca enlaces simbólicos
BUSQUEDA POR TAMAÑO
    -size +100M     # Archivos mayores a 100 Megabytes (c, b, k, M y G | + ó -)
BUSQUEDA POR TIEMPO
    -mtime -7   # Modificados en los últimos 7 días.
    -mmin -60   # Modificados en los últimos 60 minutos.
    -atime -1   # Accedidos en el último día.
BUSQUEDA POR USUARIO Y PERMISO
    -user usuario   # Archivos que pertenecen a un usuario específico.
    -perm 777       # Archivos con permisos 777.
ACCIONES SOBRE RESULTADOS
    -delete                 # Borra los archivos encontrados
    -exec [comando] {} \;   # Ejecuta un comando sobre cada resultado
    -ls                     # Muestra información detallada (tipo ls -dils)
OPERADORES LOGICOS
    -o          # Operador OR 
    -not ó -!    # Operador NOT
    -a          # Operador AND (es el comportamiento por defecto)


╔═════════════════════════════════════════════════════╗
║  REDIRECCIONES TUBERIAS Y EXPRESIONES REGULARES     ║
╚═════════════════════════════════════════════════════╝

Todo lo descrito a continuación se usa para complementar comandos y redirigir salidas

DESCRIPTORES DE ARCHIVO
    0 # Entrada estándar (stdin) - Teclado
    1 # Salida estándar (stdout) - Pantalla
    2 # Salida de error (stderr) - Pantalla (mensajes de error)
OPERADORES DE REDIRECCIÓN
    >                     # Redirige la salida estándar a un fichero (sobrescribe/trunca)
    >>                    # Redirige la salida estándar a un fichero (añade al final/append)
    2>                    # Redirige solo los errores (descriptor 2) a un fichero
    2>>                   # Añade los errores (descriptor 2) al final de un fichero
    &> ó > archivo 2>&1   # Redirige la salida estándar (descriptor 1) a archivo, redirige los errores (descriptor 2) a donde apunta la salida estandar
    <                     # Redirige la entrada estándar desde un fichero hacia un comando
    | (Tubería/Pipe)      # Pasa la salida de un comando como entrada al siguiente
DISPOSITIVOS ESPECIALES
    /dev/null   # El "agujero negro" del sistema. Se usa para descartar salidas no deseadas
COMANDOS DE INSPECCION Y FILTRO
    cat         # Muestra el contenido de un archivo
    sort        # Ordena las líneas de un texto o archivo
    grep        # Busca patrones (texto o expresiones regulares) dentro de archivos
    echo $?     # Muestra el código de salida del último comando ejecutado (0 = éxito)
EXPRESIONES REGULARES
    .       # Representa cualquier carácter único
    *       # El carácter anterior se repite 0 o más veces
    $       # Indica el final de una línea [ja$ busca palabras que terminan en ja]
    ^       # Indica el inicio de una línea
    [ ]     # Define un rango o conjunto de caracteres [a-z]
    {n,m}   # El carácter anterior se repite entre n y m veces (requiere grep -E)

[-------------- GREP --------------]
$ grep <patron> <fichero1> <fichero2>   # Busca líneas que coincidan con un patrón (expresión regular)
                                        # Imprime las líneas que contienen el patrón
                                        # El patrón puede ser texto literal o una expresión regular
    -i              # Ignora mayúsculas y minúsculas
    -v              # Muestra las líneas que NO coinciden con el patrón
    -n              # Muestra el número de línea
    -c              # Cuenta el número de líneas que coinciden
    -l              # Muestra solo los nombres de ficheros que coinciden
    -w              # Busca palabras completas
    -r              # Búsqueda recursiva en directorios
    -E              # Usa expresiones regulares extendidas (egrep)
    -F              # Búsqueda de texto literal (sin expresiones regulares)
    --color=auto    # Resalta las coincidencias

╔═════════════════════════════════════════════════════╗
║               PROGRAMACIÓN EN SHELL                 ║
╚═════════════════════════════════════════════════════╝

SCRIPT SHELL
Fichero de texto que contiene comandos de bash y se ejecuta como un programa.

Primera línea del script. Indica qué intérprete debe ejecutar el script.
#!/bin/bash
--
    chmod +x script.sh  # Otorga permiso de ejecución a un script

Ejecuta el script desde el directorio actual
./script.sh

variable=$(comando)
Guarda la salida estándar del comando en una variable
--
    cut -d':' -f1 fichero   # Divide líneas usando un delimitador y selecciona campos útil para procesar texto
    seq 1 5 # Genera una secuencia de números (1 2 3 4 5)

========= ARGUMENTOS =========
$0      # Nombre del script
$1      # Primer argumento pasado al script
$2      # Segundo argumento pasado al script
$#      # Número total de argumentos
$@      # Lista de todos los argumentos

======= CÓDIGO DE SALIDA =======
    exit N  # Finaliza el script devolviendo el código N.
            # 0  → ejecución correcta
            # ≠0 → error

======= CONDICIONALES =======
    if [ condición ]; then
        comandos
    else
        comandos
    fi
CONDICIONES COMUNES
    -f fichero              # Verdadero si existe y es un fichero regular
    -d directorio           # Verdadero si es un directorio
    -e ruta                 # Verdadero si existe
    -ne / -eq / -lt / -gt   # Comparaciones numéricas

======= BUCLES =======
Foreach itera sobre una lista de valores o ficheros.
for var in lista; do
    comandos
done
For en rango
for ((i=0; i<5; i++)); do
    echo $i
done

======= FUNCIONES =======
function nombre(){
    comandos
}
nombre(){
    comandos
}
LLAMADA
nombre_funcion argumento1 argumento2...

$ sed       # Edita texto, usado para borrar registros

# Esto es una especie de switch interactivo:
select  # Crea un menú interactivo
case    # Ejecuta acciones según la opción elegida
break   # Sale del menú (select)

[----- read -----]
$ read <VAR1> <VAR2> <VAR3>     # Comando de bash que lee una línea desde la entrada estándar y guarda el valor en una o varias variables
                                # read devuelve 0  -> lectura correcta
                                # read devuelve ≠0 -> fin de fichero o error
    -p "Mensaje: " <VAR>    # Muestra un mensaje antes de leer la entrada
    -s <VAR>                # No muestra lo que el usuario escribe (contraseñas)
    -t <SEG> <VAR>          # Espera un número limitado de segundos
    -n 1 <VAR>              # Lee un único carácter
    -r <VARIABLE>           # Evita que \ sea interpretado como carácter especial

LECTURA DESDE UN FICHERO
while read -r LINEA; do
    echo "$LINEA"
done < fichero.txt

=== ENTRADA ESTÁNDAR ===
La entrada que recibe read normalmente viene del teclado,
pero puede redirigirse desde un fichero o una tubería.


╔═════════════════════════════════════════════════════╗
║             API DEL SISTEMA OPERATIVO               ║
╚═════════════════════════════════════════════════════╝

$ gcc error error.c     # Compila un script en c
    -g  # Incluye símbolos para depurar
    -o  # Nombre del ejecutable
$ gdb ./error           # Debugea el script
    list            # Muestra el código
    break <línea>   # Pone un punto de parada
    run             # Ejecuta el programa
    step            # Entra en funciones
    next            # Avanza línea a línea
    print <var>       # Muestra el valor de una variable
    Gestión de errores

$ open  # Devuelve descriptor ≥ 0 -> éxito
        # Devuelve descriptor -1 -> error

GESTIÓN DE ERRORES
if (fd == -1) {
    perror("open");
    return 1;
}
errno       # Variable global con el código de error definida en <errno.h>
strerror(3) # Convierte errno en un mensaje legible

LIBRERIAS Y LLAMADAS AL SISTEMA
id          # Comando que muestra información del usuario
getpwuid    # Función de librería que devuelve información de un usuario (Nombre, grupo y directorio home)
getuid      # Llamada al sistema que obtiene el ID del usuario actual
mi_id       # Con argumento -> muestra datos del usuario
            # Sin argumento -> usa el UID del proceso

INFORMACION DEL SISTEMA
uname(1)    # Comando que muestra información del sistema
uname(2)    # Llamada al sistema que obtiene:
        # Nombre del SO
        # Versión del kernel
        # Nombre del host
        # Arquitectura